generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Enum representing the roles of a user in the system.
///
/// Possible values:
/// - USER: Represents a regular user.
/// - ADMIN: Represents an administrator user.
enum UserRole {
  USER
  ADMIN
}

/// Model representing a User in the database.
///
/// Attributes:
/// - id: String, the unique identifier for the User.
/// - name: String, the name of the User.
/// - email: String, the email address of the User (must be unique).
/// - emailVerified: DateTime, the date and time when the email was verified.
/// - image: String, the URL of the User's profile image.
/// - password: String, the hashed password of the User.
/// - role: UserRole, the role of the User (default is USER).
/// - accounts: List of Account objects associated with the User.
///
/// Note: This model is used to store user information in the database.
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          UserRole  @default(USER)
  accounts      Account[]
}

/// Model representing an Account in the database.
///
/// Attributes:
/// - id: The unique identifier for the Account.
/// - userId: The ID of the User associated with the Account.
/// - type: The type of the Account.
/// - provider: The provider of the Account.
/// - providerAccountId: The provider-specific ID of the Account.
/// - refresh_token: The refresh token for the Account (optional).
/// - access_token: The access token for the Account (optional).
/// - expires_at: The expiration timestamp for the access token (optional).
/// - token_type: The type of the access token (optional).
/// - scope: The scope of the access token (optional).
/// - id_token: The ID token for the Account (optional).
/// - session_state: The session state for the Account (optional).
///
/// Relations:
/// - user: The User associated with the Account.
///
/// Unique Constraints:
/// - provider and providerAccountId must be unique together.
///
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

/// Model representing a verification token.
///
/// Attributes:
/// - id: The unique identifier of the token.
/// - email: The email associated with the token.
/// - token: The unique token value.
/// - expires: The expiration date and time of the token.
///
/// Constraints:
/// - The combination of email and token must be unique.
model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@index([email])
}

/// Model representing a password reset token.
///
/// Attributes:
/// - id: The unique identifier of the token.
/// - email: The email associated with the token.
/// - token: The unique token value.
/// - expired: The expiration date and time of the token.
///
/// Constraints:
/// - The combination of email and token must be unique.
model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token])
  @@index([email])
}
